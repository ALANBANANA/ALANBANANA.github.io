# 深度优先搜索(DFS)

## Day 8-10 深度优先搜索定义

### 定义

> DFS(Depth First Search): 用于搜索树或图结构的算法。采用了回溯思想，从起始点出发，沿着一条路径尽可能深入访问节点，直到无法继续前进时为止回溯到上一个为访问的节点，然后继续深度搜索未访问过的节点，直到遍历完所有节点

其实可以采用栈的思想将遍历过的节点放回在一起，以便于回溯的时候可以继续访问他们[先进后出]的思路--->递归和堆栈

### 深度优先搜索的算法步骤

以无向图为例：

1. 选择起始节点u，并将其标记为已经访问过的节点![深度优先搜索 1](https://datawhalechina.github.io/leetcode-notes/images/202309042321406.png)
2. 检查当前节点是否为目标节点![深度优先搜索 2](https://datawhalechina.github.io/leetcode-notes/images/202309042323911.png)
3. 如果当前节点为目标节点，则可以直接返回结果![深度优先搜索 3](https://datawhalechina.github.io/leetcode-notes/images/202309042324370.png)
4. 如果当前节点不是目标节点，则遍历当前节点的所有未访问的邻节点![深度优先搜索 4](https://datawhalechina.github.io/leetcode-notes/images/202309042325587.png)
5. 对每个未访问的邻节点，从节点v出发继续进行深度优先搜索![深度优先搜索 5](https://datawhalechina.github.io/leetcode-notes/images/202309042325689.png)
6. 假如节点u没有未访问邻近节点，回溯至上一个节点，继续搜索其余路径![深度优先搜索 6](https://datawhalechina.github.io/leetcode-notes/images/202309042325770.png)
7. 重复上述步骤，直至所有图上的点完成为止

### 基于递归法的深度优先搜索算法实现

1. 定义一个graph为存储无向图的嵌套数组变量，visited为标记访问节点的集合变量。u为当前遍历边的开始节点。定义一个函数，用以实现深度优先搜索的递归
2. 选择起始节点u，并将其标记为已经遍历过的，将u放进一个集合里面(在集合里面是不允许有重复元素的)
3. 检查节点是不是目标节点
4. 假如节点是目标节点，立即返回结果
5. 如果当前节点不是目标节点，则可以遍历该节点周围为访问的节点，对每一个没有被遍历的节点采用递归
6. 如果节点u没有未访问的相邻节点，则回溯到最近访问的节点(假如第一个开始沿路先往后面都没有就回到第一个寻找其他路径)
7. 重复上述的3-6，直到遍历完为止

```python
class Solution:
    def dfs_recursive(self, graph, u, visited):
        """"""
        print(u)                        # 访问节点
        visited.add(u)                  # 节点 u 标记其已访问

        for v in graph[u]:  # 看是否在集合里面
            if v not in visited:        # 节点 v 未访问过
                # 深度优先搜索遍历节点
                self.dfs_recursive(graph, v, visited)  # 递归过程，假如节点内的指向点全部已经在集合里，那么则回返回for里面当前点的下一个点，这个则是直接多支沟进行，下面的递归不行，则返回上一层继续遍历下一个元素然后在递归下去，又不行又回到循环，直到如果所有循环不行回到起始点找下一个，直到全结束
        
graph = {
    "A": ["B", "C"],
    "B": ["A", "C", "D"],
    "C": ["A", "B", "D", "E"],
    "D": ["B", "C", "E", "F"],
    "E": ["C", "D"],
    "F": ["D", "G"],
    "G": []
}  # 该字典主要是表示每一个节点指向的位置，表示一个点指向多个位置

# 基于递归实现的深度优先搜索
visited = set()
Solution().dfs_recursive(graph, "A", visited)

```

### 基于堆栈实现的深度优先搜索

1. 定义一个无向图graph为存储嵌套数组变量，visited为标记访问节点得集合变量。start是当前开始的遍历的起点。而栈是用于存放节点访问记录的栈结构，前面部分是节点的代表，后半部分是结点指向的第几个点
2. 决定起始点之后，检查当前节点u是否为目标节点
3. 如果是目标节点，则寻找已经结束了
4. 如果当前节点不是目标节点，则将当前节点以及下一个要访问的节点的索引存放于栈中，并标记该节点已经被遍历，即代码部分if那一段
5. 而此时验证栈是否为空，以及下一个将访问的节点和其下标
6. 第一个if循环则是取放进栈里面，第二个则是验证是不是重复值遍历一个表直至找到没有重复的(即取出为遍历的点)，然后放入新栈内，并标记已经访问
7. 接下来就是重复以上步骤然后即可遍历完所有点

```python
class Solution:
    def dfs_stack(self, graph, u):
        """以下四则则是直接访问最起始的店"""
        print(u)                            # 访问节点 u
        visited, stack = set(), []          # 使用 visited 标记访问过的节点, 使用栈 stack 存放临时节点
        
        stack.append([u, 0])                # 将节点 u，节点 u 的下一个邻接节点下标放入栈中，下次将遍历 graph[u][0]
        visited.add(u)                      # 将起始节点 u 标记为已访问
        
    	"""这里则是开始遍历节点"""
        while stack:
            u, i = stack.pop()              # 取出节点 u，以及节点 u 下一个将要访问的邻接节点下标 i
            
            if i < len(graph[u]):
                v = graph[u][i]             # 取出邻接节点 v，字典中的值是一列表，每一个不同的遍历
                stack.append([u, i + 1])    # 下一次将遍历 graph[u][i + 1]----->几乎是通过下面是否有相同的点然后新加和带入
                if v not in visited:        # 验证节点 v 是否被访问过，没有则返回while循环查看
                    print(v)                # 访问节点 v
                    stack.append([v, 0])    # 下一次将遍历 graph[v][0]，这个则是新点加入栈中看能不能继续找寻下一个
                    visited.add(v)          # 将节点 v 标记为已访问                
        """在弹出一个栈的数据的时候的索引，如果在得到v那一步得到一个重复的值，那么这个重复的值会在第二个if处进行验证，但实际在验证之前的stack.append([u, u+1])中已经开始寻找了下一个并压入栈中代替之前弹出的"""

graph = {
    "A": ["B", "C"],
    "B": ["A", "C", "D"],
    "C": ["A", "B", "D", "E"],
    "D": ["B", "C", "E", "F"],
    "E": ["C", "D"],
    "F": ["D", "G"],
    "G": []
}

# 基于堆栈实现的深度优先搜索
Solution().dfs_stack(graph, "A")

```

### 总结

感觉这一章很简单，当初数学建模上碰到了迪杰斯特拉算法，以为这就是迪杰斯特拉算法，但貌似，DFS采用的更是一种递归的思维，算是计算机里面比较抽象的一种算法吧，迪杰斯特拉是一种贪心的，所以又与之不同，在于它更在乎遍历点不可以重复，另外对于遍历过的点的取消，要注意先后位置，我在求解关于岛屿问题上，采用了如果当前点为1的和0的两种是完全不同的，如果先是为1的话，要先把前面的已经为1遍历过的点表示已经遍历，而后再进行接下面的点的遍历，没有则返回上一层。而关于0的求解则是反过来的证明是否为，所以在不同判定的情况之下，更要注意前面和后面的关联，否则会出现错误。









































